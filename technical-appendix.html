<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Technical Appendix — Farming CBA Decision Tool</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Technical appendix for the Farming CBA Decision Tool. Methods, formulas, replicate baselines, scaling rules, and sensitivity grid definitions." />

  <link rel="stylesheet" href="styles.css" />

  <style>
    /* Appendix-specific layout that reuses styles.css tokens and components */
    .appendix-shell { max-width: var(--max); margin: 0 auto; padding: 18px 16px 28px; }
    .appendix-hero { margin-top: 12px; }
    .appendix-hero .kicker { font-size: 12px; letter-spacing: 0.12em; text-transform: uppercase; color: var(--muted); }
    .appendix-hero h1 { margin-top: 6px; margin-bottom: 8px; font-size: 26px; }
    .appendix-hero .sub { color: var(--muted); max-width: 85ch; }
    .appendix-actions { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; margin-top: 12px; }
    .toc { margin-top: 14px; display: grid; gap: 10px; }
    .toc-grid { display: grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 10px; }
    .toc a {
      display: flex; align-items: center; justify-content: space-between; gap: 12px;
      border-radius: 14px; border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
      padding: 10px 12px; color: var(--text);
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
      text-decoration: none;
    }
    .toc a:hover { transform: translateY(-1px); border-color: var(--border-2); background: rgba(255,255,255,0.06); }
    .toc .label { font-weight: 800; font-size: 13px; line-height: 1.2; }
    .toc .hint { font-size: 12px; color: var(--muted); text-align: right; white-space: nowrap; }
    .math {
      font-family: var(--mono);
      font-size: 12px;
      background: rgba(0,0,0,0.28);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px 12px;
      white-space: pre-wrap;
      line-height: 1.45;
      color: rgba(255,255,255,0.88);
      overflow-x: auto;
    }
    .mono { font-family: var(--mono); }
    .callout-compact { margin-top: 10px; }
    .kbd {
      font-family: var(--mono);
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
      color: rgba(255,255,255,0.90);
      white-space: nowrap;
    }
    .hr { height: 1px; background: var(--border); margin: 14px 0; }

    .backtop {
      position: fixed; right: 16px; bottom: 16px; z-index: 1000;
      opacity: 0; transform: translateY(8px);
      pointer-events: none; transition: opacity 160ms ease, transform 160ms ease;
    }
    .backtop.show { opacity: 1; transform: translateY(0); pointer-events: auto; }

    @media (max-width: 980px){
      .toc-grid { grid-template-columns: 1fr; }
    }
  </style>
</head>

<body>
  <header class="app-header" role="banner">
    <div class="brand">
      <div style="display:flex; align-items:center; gap:12px; min-width:0;">
        <div class="brand-mark" aria-hidden="true">CBA</div>
        <div class="brand-text" style="min-width:0;">
          <div class="brand-title">Farming CBA Decision Tool</div>
          <div class="brand-subtitle">Technical appendix (methods, formulas, audit notes)</div>
        </div>
      </div>
      <div class="header-actions">
        <a class="btn small" href="index.html" aria-label="Back to main tool">Back to tool</a>
        <button class="btn small primary" id="printBtn" type="button" aria-label="Print technical appendix">Print</button>
      </div>
    </div>
  </header>

  <main class="appendix-shell" id="content" role="main">
    <section class="card appendix-hero" aria-labelledby="t-title">
      <div class="kicker">Technical appendix</div>
      <h1 id="t-title">Methods, formulas, scaling rules, replicate baselines, and sensitivity grid</h1>
      <p class="sub">
        This appendix documents the exact accounting logic used by the tool. The main tool is written for practical use and avoids technical terminology where possible. Definitions, formulas, and implementation details are recorded here for review, replication, and audit.
      </p>

      <div class="callout callout-compact">
        <div class="badge warn">Important</div>
        <p class="small muted" style="margin-top:8px;">
          Monetary units are whatever currency you input (often AUD). The engine treats all monetary fields consistently and never mixes currencies. Missing values are treated as missing and excluded from means and totals (never forced to zero). The character <span class="kbd">?</span> is treated as missing.
        </p>
      </div>

      <div class="toc" aria-label="Table of contents">
        <div class="small muted" style="font-weight:800; letter-spacing:-0.01em;">Contents</div>
        <div class="toc-grid">
          <a href="#sec-1"><span class="label">1. Data model</span><span class="hint">records, units, missingness</span></a>
          <a href="#sec-2"><span class="label">2. Replicate baselines</span><span class="hint">control within replicate</span></a>
          <a href="#sec-3"><span class="label">3. Plot deltas</span><span class="hint">treatment minus baseline</span></a>
          <a href="#sec-4"><span class="label">4. Scaling rule</span><span class="hint">per-ha to farm totals</span></a>
          <a href="#sec-5"><span class="label">5. Discounted CBA</span><span class="hint">PV, NPV, BCR, ROI</span></a>
          <a href="#sec-6"><span class="label">6. Recurrence and persistence</span><span class="hint">cost cadence and benefit duration</span></a>
          <a href="#sec-7"><span class="label">7. Sensitivity grid</span><span class="hint">price × r × persistence × recurrence</span></a>
          <a href="#sec-8"><span class="label">8. Rankings and reporting</span><span class="hint">comparison-to-control table</span></a>
          <a href="#sec-9"><span class="label">9. Reproducibility</span><span class="hint">exports, scenario JSON</span></a>
        </div>
      </div>
    </section>

    <section id="sec-1" class="card">
      <div class="card-head">
        <h2>1. Data model (records, units, and missing values)</h2>
      </div>

      <div class="prose">
        <p>
          The tool ingests trial-style data at the <span class="mono">plot</span> level and produces treatment summaries compared against a designated control. The minimum conceptual structure is:
          (i) a plot identifier, (ii) a replicate identifier, (iii) a treatment identifier or name, (iv) a control flag, (v) plot area, and (vi) one or more numeric outcome and cost fields used to calculate deltas relative to control.
        </p>

        <p>
          The engine supports import from TSV or CSV (upload or paste). Parsing is delimiter-aware and attempts to identify a data dictionary section when present. Validation checks include required columns, numeric coercion, and missingness rates. Missing values are represented as empty strings, <span class="kbd">NA</span>, <span class="kbd">NaN</span>, or <span class="kbd">?</span>, and are treated as missing (excluded from means and totals rather than set to zero).
        </p>

        <div class="hr"></div>

        <p class="small muted">
          Notation used in later sections: plots are indexed by <span class="mono">i</span>, replicates by <span class="mono">r</span>, treatments by <span class="mono">k</span>, and years by <span class="mono">t</span>. The analysis horizon is <span class="mono">T</span> years, with <span class="mono">t = 0</span> denoting the present (year 0).
        </p>
      </div>
    </section>

    <section id="sec-2" class="card">
      <div class="card-head">
        <h2>2. Replicate-specific control baselines</h2>
      </div>

      <div class="prose">
        <p>
          Trial plots are typically blocked into replicates to control for spatial heterogeneity. The tool therefore defines the control baseline <em>within each replicate</em>, rather than using a single global control average. This prevents treatment effects from being confounded by replicate-to-replicate differences.
        </p>

        <p>
          For each replicate <span class="mono">r</span>, and for each outcome variable <span class="mono">Y</span> used to compute benefits (for example yield per hectare), the replicate control baseline is the missing-safe mean across control plots in that replicate:
        </p>

        <div class="math" aria-label="Replicate control baseline formula">
Let C(r) be the set of plots in replicate r flagged as control.
Let Y_i be the outcome value for plot i (missing values excluded).

Baseline control outcome within replicate r:
  Ȳ_control,r = mean{ Y_i : i ∈ C(r), Y_i is observed }

If a replicate has no usable control observations for Y, the replicate baseline for that outcome is treated as missing and is flagged in Data Checks.
        </div>

        <p>
          The same logic applies to cost fields when the analysis uses plot-level costs. If costs are specified at the treatment level rather than plot level, replicate baselines apply primarily to outcomes that drive benefits (yield, quality measures, or other output differences).
        </p>
      </div>
    </section>

    <section id="sec-3" class="card">
      <div class="card-head">
        <h2>3. Plot-level deltas and treatment summaries</h2>
      </div>

      <div class="prose">
        <p>
          Once replicate control baselines are defined, the tool computes a replicate-adjusted delta for each plot. For a plot <span class="mono">i</span> in replicate <span class="mono">r(i)</span>, the delta for an outcome <span class="mono">Y</span> is:
        </p>

        <div class="math" aria-label="Plot delta formula">
Delta for plot i (outcome Y):
  ΔY_i = Y_i − Ȳ_control,r(i)

This is only computed when both Y_i and Ȳ_control,r(i) are observed.
        </div>

        <p>
          Treatment-level effects are then summarised from plot deltas. For each treatment <span class="mono">k</span> and outcome <span class="mono">Y</span>, the tool computes a missing-safe mean delta:
        </p>

        <div class="math" aria-label="Treatment mean delta formula">
Let P(k) be the set of plots assigned to treatment k.
Let ΔY_i be defined as above (missing excluded).

Mean treatment delta:
  ΔȲ_k = mean{ ΔY_i : i ∈ P(k), ΔY_i is observed }
        </div>

        <p>
          The same structure applies to plot-level cost variables where applicable. The tool also records counts of usable observations by treatment and replicate, and flags situations where outcomes are observed but replicate control baselines are not (for example missing control data in a replicate).
        </p>
      </div>
    </section>

    <section id="sec-4" class="card">
      <div class="card-head">
        <h2>4. Scaling rule (from plot deltas to farm-level annual flows)</h2>
      </div>

      <div class="prose">
        <p>
          The tool is control-centric: all benefits and incremental costs are defined relative to the control. The scaling rule converts replicate-adjusted treatment deltas into annual monetary flows for a chosen analysis area.
        </p>

        <p>
          The engine uses a per-hectare normalisation before scaling up. If an outcome is measured per hectare (for example <span class="mono">t/ha</span>), the delta is already per hectare. If an outcome is recorded per plot, it is converted to per hectare using plot area before scaling.
        </p>

        <div class="math" aria-label="Per hectare normalisation and scaling rule">
Per-hectare delta (generic):
  If Y is per hectare already:   Δy_k = ΔȲ_k
  If Y is per plot total:        Δy_k = ΔȲ_k / mean_plot_area_k   (using non-missing plot areas)

Farm/analysis area:
  A = target area in hectares (entered in the tool)

Adoption multiplier (scenario):
  a ∈ [0, 1] (scenario setting; can differ by scenario and by sensitivity run)

Adopted area:
  A_adopted = A × a

Monetised annual benefit flow for treatment k:
  Benefit_k,annual = (Δy_k × price_per_unit) × A_adopted

Incremental annual variable cost flow for treatment k:
  VarCost_k,annual = (Δc_k,per_ha) × A_adopted

Incremental fixed cost for treatment k (if specified as fixed, not per hectare):
  FixCost_k,annual = fixed_amount_k  (not multiplied by A)
        </div>

        <p>
          The tool’s “cost scaling rule” is therefore: per-hectare incremental costs scale with adopted area; fixed costs do not. If the imported data express a cost as a plot total, the engine first converts it to per hectare using plot area (in the same way as outcomes) and then scales by adopted area.
        </p>

        <div class="callout">
          <div class="badge">Control column</div>
          <p class="small muted" style="margin-top:8px;">
            In the Results tab comparison table, the control is shown as the baseline. Incremental benefits and costs for each treatment are computed relative to the control, so the control’s incremental values are zero by construction. Total (non-incremental) reporting can be exported, but the ranking logic uses incremental outcomes relative to control.
          </p>
        </div>
      </div>
    </section>

    <section id="sec-5" class="card">
      <div class="card-head">
        <h2>5. Discounted cost–benefit analysis (PV formulas and indicators)</h2>
      </div>

      <div class="prose">
        <p>
          The engine constructs annual incremental flows for each treatment <span class="mono">k</span>: benefits <span class="mono">B_k(t)</span> and costs <span class="mono">C_k(t)</span> for years <span class="mono">t = 0, 1, …, T</span>. Discounting uses a constant annual discount rate <span class="mono">r</span> for a given run.
        </p>

        <p>
          Discount factor: <span class="mono">DF(t) = 1 / (1 + r)^t</span>. Year 0 uses <span class="mono">DF(0)=1</span>, so year-0 (capital) costs are not discounted.
        </p>

        <div class="math" aria-label="Present value formulas">
Present value of benefits:
  PV_B(k) = Σ_{t=0..T}  B_k(t) / (1 + r)^t

Present value of costs:
  PV_C(k) = Σ_{t=0..T}  C_k(t) / (1 + r)^t

Net present value:
  NPV(k) = PV_B(k) − PV_C(k)

Benefit–cost ratio:
  BCR(k) = PV_B(k) / PV_C(k)    (defined when PV_C(k) > 0)

Return on investment:
  ROI(k) = NPV(k) / PV_C(k)     (defined when PV_C(k) > 0)
        </div>

        <p>
          All indicators are computed on the same incremental basis (relative to the control). The comparison-to-control table reports <span class="mono">PV_B</span>, <span class="mono">PV_C</span>, <span class="mono">NPV</span>, <span class="mono">BCR</span>, and <span class="mono">ROI</span>, and additionally reports deltas versus control where meaningful (for example <span class="mono">ΔNPV</span> and <span class="mono">ΔPV_C</span>, both absolute and percentage where the denominator is non-zero).
        </p>
      </div>
    </section>

    <section id="sec-6" class="card">
      <div class="card-head">
        <h2>6. Recurrence and persistence (per-treatment settings)</h2>
      </div>

      <div class="prose">
        <p>
          The tool supports treatment-specific recurrence for incremental costs and treatment-specific persistence for incremental benefits. These settings are configured in the Configuration tab and are applied in both the base run and the sensitivity grid.
        </p>

        <div class="math" aria-label="Recurrence and persistence definitions">
Cost recurrence for treatment k:
  - Once (year 0):         incremental costs applied at t = 0 only
  - Annual:                incremental costs applied for each year t = 1..T (or t = 0..T if specified)
  - Every m years:         incremental costs applied at t = 0, m, 2m, ... ≤ T

Benefit persistence for treatment k:
  - Benefits apply through year P (persistence horizon), then drop to 0 afterwards:
      B_k(t) = B_k,annual for t = 1..P
      B_k(t) = 0          for t = P+1..T

If persistence P ≥ T, benefits persist for the full analysis horizon.
        </div>

        <p>
          When both persistence and recurrence are set, the engine constructs <span class="mono">B_k(t)</span> and <span class="mono">C_k(t)</span> accordingly and then applies the discounting formulas in Section 5. In the sensitivity grid, persistence can be varied independently from discount rate and price.
        </p>
      </div>
    </section>

    <section id="sec-7" class="card">
      <div class="card-head">
        <h2>7. Sensitivity grid (price × discount rate × persistence × recurrence)</h2>
      </div>

      <div class="prose">
        <p>
          The sensitivity grid is a deterministic sweep across user-defined sets of assumptions. For each treatment, the tool recalculates all indicators under each combination of:
          (i) price multiplier, (ii) discount rate, (iii) benefit persistence, and (iv) cost recurrence.
        </p>

        <div class="math" aria-label="Sensitivity grid definition">
Let:
  M_price = {m1, m2, ...}   (price multipliers, e.g., 0.8, 1.0, 1.2)
  R       = {r1, r2, ...}   (discount rates, e.g., 0.04, 0.07, 0.10)
  P       = {p1, p2, ...}   (persistence horizons in years, e.g., 1, 3, 5, 10)
  G_k     = {g1, g2, ...}   (recurrence options for treatment k, e.g., once, annual, every 2 years)

For each treatment k and each tuple (m, r, p, g):
  - Replace price_per_unit with (m × price_per_unit)
  - Construct B_k(t) using persistence p
  - Construct C_k(t) using recurrence g
  - Compute PV_B(k), PV_C(k), NPV(k), BCR(k), ROI(k) using rate r

The grid outputs one row per (treatment, m, r, p, g) combination.
        </div>

        <p>
          The sensitivity export includes the full grid (so results can be filtered and graphed outside the tool) and preserves the exact parameter combination used for each row.
        </p>

        <div class="callout">
          <div class="badge warn">Interpretation note</div>
          <p class="small muted" style="margin-top:8px;">
            Price multipliers affect benefits (revenue-linked outputs). They do not change costs unless a cost item is explicitly tied to price in the imported data. Discount rate changes the weight placed on later years. Persistence changes how long benefits last. Recurrence changes how often costs recur.
          </p>
        </div>
      </div>
    </section>

    <section id="sec-8" class="card">
      <div class="card-head">
        <h2>8. Rankings, comparison-to-control table, and deltas</h2>
      </div>

      <div class="prose">
        <p>
          The Results tab uses a single comparison-to-control table as the default view. Rows are indicators and columns are Control plus each treatment. For each treatment, the table also reports deltas versus control:
          absolute deltas and, where meaningful, percentage deltas (with denominators checked to avoid division by zero).
        </p>

        <p>
          Ranking is computed from the chosen primary metric (typically NPV under the base scenario). If two treatments tie within rounding, the tool breaks ties using a secondary metric (for example PV benefits) to produce a stable ordering.
        </p>

        <div class="math" aria-label="Delta and percent-delta conventions">
Absolute delta vs control (indicator X):
  ΔX_k = X_k − X_control

Percent delta vs control (indicator X), when X_control ≠ 0:
  %ΔX_k = 100 × (X_k − X_control) / |X_control|

If the denominator is zero or missing, the percent delta is not reported (left blank) and is flagged in Data Checks when relevant.
        </div>
      </div>
    </section>

    <section id="sec-9" class="card">
      <div class="card-head">
        <h2>9. Reproducibility, exports, and audit notes</h2>
      </div>

      <div class="prose">
        <p>
          The tool supports exports designed for replication and review:
          cleaned dataset export (TSV), treatment summary export (CSV), sensitivity grid export (CSV), and scenario JSON save/load to preserve configuration settings (including per-treatment recurrence and persistence).
        </p>

        <p>
          A scenario JSON is a complete snapshot of (i) the cleaned dataset (or a pointer to it, depending on settings), (ii) project settings, (iii) discount rate and horizon, (iv) price assumptions, and (v) recurrence and persistence settings. Re-loading the scenario reproduces the same base results, subject only to deterministic calculations (no Monte Carlo elements are included unless explicitly exported).
        </p>

        <div class="callout">
          <div class="badge">Audit checklist</div>
          <div class="kv" style="margin-top:10px;">
            <div class="k">Missing values</div><div>Never imputed to zero; excluded from means/totals; “?” treated as missing.</div>
            <div class="k">Baselines</div><div>Computed within replicate using control plots only (missing-safe).</div>
            <div class="k">Deltas</div><div>Plot deltas are replicate-adjusted; treatment effects summarised from deltas.</div>
            <div class="k">Scaling</div><div>Per-hectare normalisation; per-ha values scale with adopted area; fixed costs do not.</div>
            <div class="k">Discounting</div><div>PV uses Σ CF(t)/(1+r)^t with year 0 undiscounted.</div>
            <div class="k">Sensitivity grid</div><div>Full Cartesian product across price multipliers, discount rates, persistence, and recurrence.</div>
          </div>
        </div>

        <p class="small muted" style="margin-top:12px;">
          If you are archiving results, store (a) the scenario JSON, (b) the cleaned dataset TSV, and (c) the sensitivity grid CSV alongside any narrative report. This preserves both the inputs and the model configuration used to generate the outputs.
        </p>
      </div>
    </section>
  </main>

  <div class="backtop" id="backTopWrap">
    <button class="btn primary" id="backToTop" type="button" aria-label="Back to top">Back to top</button>
  </div>

  <script>
    (function () {
      const printBtn = document.getElementById("printBtn");
      if (printBtn) printBtn.addEventListener("click", () => window.print());

      const wrap = document.getElementById("backTopWrap");
      const btn = document.getElementById("backToTop");

      const onScroll = () => {
        const y = window.scrollY || document.documentElement.scrollTop || 0;
        if (wrap) wrap.classList.toggle("show", y > 650);
      };

      if (btn) btn.addEventListener("click", () => window.scrollTo({ top: 0, behavior: "smooth" }));
      window.addEventListener("scroll", onScroll, { passive: true });
      onScroll();
    })();
  </script>
</body>
</html>
